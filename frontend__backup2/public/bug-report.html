<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bug Report Form</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #0b1021;
      color: white;
    }
    .container {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 40px;
    }
    h1 {
      font-size: 24px;
      background: linear-gradient(to right, #6d4aff, #8c5eff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }
    .back-button {
      display: inline-block;
      padding: 8px 16px;
      background-color: #242d4f;
      color: white;
      text-decoration: none;
      border-radius: 8px;
      transition: background-color 0.2s;
    }
    .back-button:hover {
      background-color: #343e60;
    }
    .form-container {
      max-width: 600px;
      margin: 0 auto;
      background-color: #121833;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .form-group {
      margin-bottom: 16px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #8c8c8c;
    }
    input, textarea, select {
      width: 100%;
      padding: 8px;
      background-color: #0f1428;
      border: 1px solid #1e2642;
      color: white;
      border-radius: 4px;
      box-sizing: border-box;
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    .submit-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: auto;
      padding: 10px 24px;
      background: linear-gradient(to right, #6d4aff, #8c5eff);
      color: white;
      border: none;
      border-radius: 9999px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: opacity 0.2s;
    }
    .submit-button:hover {
      opacity: 0.9;
    }
    .submit-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .button {
      display: inline-flex;
      align-items: center;
      padding: 8px 16px;
      background-color: #242d4f;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .button:hover {
      background-color: #343e60;
    }
    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      margin-top: 16px;
    }
    .checkbox-container input {
      width: auto;
      margin-right: 8px;
    }
    .checkbox-container label {
      margin-bottom: 0;
      font-size: 14px;
    }
    .file-upload-container {
      border: 2px dashed #1e2642;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      transition: border-color 0.2s;
    }
    .file-upload-container:hover {
      border-color: #6d4aff;
    }
    .file-input {
      display: none;
    }
    .file-list {
      margin-top: 16px;
      padding: 0;
      list-style: none;
    }
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin-bottom: 8px;
      background-color: #0f1428;
      border-radius: 4px;
    }
    .file-info {
      display: flex;
      align-items: center;
    }
    .file-name {
      margin-right: 8px;
    }
    .file-status {
      font-size: 12px;
    }
    .status-uploading {
      color: #ffc107;
    }
    .status-scanning {
      color: #ffc107;
    }
    .status-ready {
      color: #28a745;
    }
    .status-error {
      color: #dc3545;
    }
    .remove-file {
      color: #dc3545;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }
    .info-message {
      margin-top: 8px;
      font-size: 14px;
      color: #8c8c8c;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Bug Report Form</h1>
      <a href="/" class="back-button">Back to Chat</a>
    </header>
    
    <div class="form-container">
      <form id="bugReportForm">
        <!-- Reporter Information -->
        <h3>Reporter Information</h3>
        <div class="form-group">
          <label for="reporterName">Your Name</label>
          <input type="text" id="reporterName" name="reporterName" required>
        </div>
        
        <div class="form-group">
          <label for="reporterEmail">Your Email</label>
          <input type="email" id="reporterEmail" name="reporterEmail" required>
        </div>
        
        <!-- Device Information -->
        <h3>Device Information</h3>
        <div class="form-group">
          <label for="appVersion">App Version (e.g. 1.2.3 (1234))</label>
          <input type="text" id="appVersion" name="appVersion" required>
        </div>
        
        <div class="form-group">
          <label for="deviceOS">Device/OS (e.g. iPad Pro 11" M2, iPadOS 17.4)</label>
          <input type="text" id="deviceOS" name="deviceOS" required>
        </div>
        
        <!-- Bug Description -->
        <h3>Bug Description</h3>
        <div class="form-group">
          <label for="stepsToReproduce">Steps to Reproduce (at least 3 steps)</label>
          <textarea id="stepsToReproduce" name="stepsToReproduce" required></textarea>
        </div>
        
        <div class="form-group">
          <label for="expectedResult">Expected Result</label>
          <textarea id="expectedResult" name="expectedResult" required></textarea>
        </div>
        
        <div class="form-group">
          <label for="actualResult">Actual Result</label>
          <textarea id="actualResult" name="actualResult" required></textarea>
        </div>
        
        <div class="form-group">
          <label for="severity">Severity</label>
          <select id="severity" name="severity" required>
            <option value="">Select Severity</option>
            <option value="Critical">Critical</option>
            <option value="High">High</option>
            <option value="Medium">Medium</option>
            <option value="Low">Low</option>
          </select>
        </div>
        
        <!-- File Attachments -->
        <h3>Attachments (Optional)</h3>
        <div class="file-upload-container" id="dropZone">
          <input type="file" id="fileInput" class="file-input" multiple>
          <div style="text-align: center;">
            <button type="button" id="selectFilesButton" class="button">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="12" y1="18" x2="12" y2="12"></line>
                <line x1="9" y1="15" x2="15" y2="15"></line>
              </svg>
              Select Files
            </button>
            <p class="info-message">
              Drag & drop files here, or click the button to select files (up to 3 files, 100 MB each)
            </p>
          </div>
          <ul class="file-list" id="fileList"></ul>
        </div>
        <div id="skipAttachmentsContainer" class="hidden">
          <button type="button" id="skipAttachmentsButton" class="button">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
            Skip Attachments
          </button>
        </div>
        
        <!-- GDPR Consent -->
        <div class="checkbox-container">
          <input type="checkbox" id="gdprConsent" name="gdprConsent" required>
          <label for="gdprConsent">I consent to storage of diagnostic data for troubleshooting purposes (GDPR)</label>
        </div>
        
        <!-- Submit Button -->
        <div style="margin-top: 24px; text-align: right;">
          <button type="submit" id="submitButton" class="submit-button">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 2v20h-20v-20h20zm-10 10v6m0-12v2m-6 16v-12m12 12v-12"></path>
            </svg>
            Submit Bug Report
          </button>
        </div>
      </form>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Constants
      const BACKEND_URL = 'http://localhost:8001';
      const MAX_FILES = 3;
      const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB in bytes
      
      // Elements
      const dropZone = document.getElementById('dropZone');
      const fileInput = document.getElementById('fileInput');
      const selectFilesButton = document.getElementById('selectFilesButton');
      const fileList = document.getElementById('fileList');
      const skipAttachmentsContainer = document.getElementById('skipAttachmentsContainer');
      const skipAttachmentsButton = document.getElementById('skipAttachmentsButton');
      const submitButton = document.getElementById('submitButton');
      const bugReportForm = document.getElementById('bugReportForm');
      
      // State
      let files = [];
      let uploadedFiles = [];
      let pollingIntervals = {};
      let allFilesReady = false;
      
      // Initialize
      function init() {
        // Set up file selection click
        selectFilesButton.addEventListener('click', function() {
          fileInput.click();
        });
        
        // Set up file input change
        fileInput.addEventListener('change', function(e) {
          handleFiles(Array.from(e.target.files));
          this.value = null; // Reset so same file can be selected again
        });
        
        // Set up drag and drop
        dropZone.addEventListener('dragover', function(e) {
          e.preventDefault();
          dropZone.style.borderColor = '#6d4aff';
        });
        
        dropZone.addEventListener('dragleave', function() {
          dropZone.style.borderColor = '#1e2642';
        });
        
        dropZone.addEventListener('drop', function(e) {
          e.preventDefault();
          dropZone.style.borderColor = '#1e2642';
          
          if (e.dataTransfer.files.length > 0) {
            handleFiles(Array.from(e.dataTransfer.files));
          }
        });
        
        // Set up skip attachments button
        skipAttachmentsButton.addEventListener('click', function() {
          skipAttachments();
        });
        
        // Set up form submission
        bugReportForm.addEventListener('submit', function(e) {
          e.preventDefault();
          submitReport();
        });
      }
      
      // Handle file selection
      function handleFiles(newFiles) {
        // Check if max files reached
        const availableSlots = MAX_FILES - files.length;
        if (availableSlots <= 0) {
          alert(`Maximum ${MAX_FILES} files allowed. Please remove some files before adding more.`);
          return;
        }
        
        // Process only up to available slot count
        const filesToAdd = newFiles.slice(0, availableSlots);
        
        // Check file sizes
        for (const file of filesToAdd) {
          if (file.size > MAX_FILE_SIZE) {
            alert(`File ${file.name} exceeds the maximum size of 100MB.`);
            return;
          }
        }
        
        // Add files to array and display
        for (const file of filesToAdd) {
          const fileId = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          
          // Add to files array
          files.push({
            id: fileId,
            file: file,
            status: 'Uploading...',
            s3Key: null
          });
          
          // Display in list
          addFileToList(fileId, file.name, 'Uploading...');
          
          // Upload file
          uploadFile(fileId, file);
        }
        
        // Update UI
        updateFileUploadUI();
      }
      
      // Add file to visual list
      function addFileToList(fileId, fileName, status) {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.dataset.fileId = fileId;
        
        let statusClass = '';
        switch (status.toLowerCase()) {
          case 'uploading...':
            statusClass = 'status-uploading';
            break;
          case 'scanning...':
          case 'uploaded, scanning...':
            statusClass = 'status-scanning';
            break;
          case 'clean (ready)':
            statusClass = 'status-ready';
            break;
          default:
            if (status.toLowerCase().includes('error') || status.toLowerCase().includes('infected')) {
              statusClass = 'status-error';
            }
        }
        
        li.innerHTML = `
          <div class="file-info">
            <span class="file-name">${fileName}</span>
            <span class="file-status ${statusClass}">${status}</span>
          </div>
          <button type="button" class="remove-file" data-file-id="${fileId}">&times;</button>
        `;
        
        fileList.appendChild(li);
        
        // Add remove button event listener
        li.querySelector('.remove-file').addEventListener('click', function() {
          removeFile(fileId);
        });
      }
      
      // Update file status in the list
      function updateFileStatus(fileId, status) {
        const li = fileList.querySelector(`li[data-file-id="${fileId}"]`);
        if (li) {
          const statusEl = li.querySelector('.file-status');
          
          // Update status text
          statusEl.textContent = status;
          
          // Update status class
          statusEl.classList.remove('status-uploading', 'status-scanning', 'status-ready', 'status-error');
          
          let statusClass = '';
          switch (status.toLowerCase()) {
            case 'uploading...':
              statusClass = 'status-uploading';
              break;
            case 'scanning...':
            case 'uploaded, scanning...':
              statusClass = 'status-scanning';
              break;
            case 'clean (ready)':
              statusClass = 'status-ready';
              break;
            default:
              if (status.toLowerCase().includes('error') || status.toLowerCase().includes('infected')) {
                statusClass = 'status-error';
              }
          }
          
          statusEl.classList.add(statusClass);
        }
      }
      
      // Remove file from list and state
      function removeFile(fileId) {
        // Clear polling interval if exists
        if (pollingIntervals[fileId]) {
          clearInterval(pollingIntervals[fileId]);
          delete pollingIntervals[fileId];
        }
        
        // Remove from files array
        files = files.filter(f => f.id !== fileId);
        
        // Remove from uploadedFiles array
        uploadedFiles = uploadedFiles.filter(f => f.id !== fileId);
        
        // Remove from DOM
        const li = fileList.querySelector(`li[data-file-id="${fileId}"]`);
        if (li) {
          li.remove();
        }
        
        // Update UI
        updateFileUploadUI();
      }
      
      // Update file upload UI based on current state
      function updateFileUploadUI() {
        // Show/hide skip attachments button based on file count
        if (files.length > 0) {
          skipAttachmentsContainer.classList.remove('hidden');
        } else {
          skipAttachmentsContainer.classList.add('hidden');
        }
        
        // Update selectFilesButton
        if (files.length >= MAX_FILES) {
          selectFilesButton.disabled = true;
          selectFilesButton.textContent = 'Maximum files reached';
        } else {
          selectFilesButton.disabled = false;
          selectFilesButton.textContent = 'Select Files';
        }
        
        // Check if all files are ready
        checkAllFilesReady();
      }
      
      // Check if all files are ready for submission
      function checkAllFilesReady() {
        allFilesReady = files.length > 0 && 
                         files.every(file => file.status === 'Clean (ready)' || file.status.includes('Infected'));
      }
      
      // Upload file to S3/R2
      async function uploadFile(fileId, file) {
        try {
          // Find file in array
          const fileIndex = files.findIndex(f => f.id === fileId);
          if (fileIndex === -1) return;
          
          // Prepare file metadata
          const safeName = file.name.replace(/\s+/g, "_");
          const meta = { 
            name: safeName, 
            type: file.type, 
            size: file.size 
          };
          
          // Request presigned URL
          const presignRes = await fetch(`${BACKEND_URL}/generate-presigned-url`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(meta)
          });
          
          if (!presignRes.ok) {
            throw new Error(`Failed to get presigned URL: ${presignRes.status}`);
          }
          
          const { url, key } = await presignRes.json();
          
          // Upload to S3/R2
          const uploadRes = await fetch(url, {
            method: 'PUT',
            body: file,
            headers: { 'Content-Type': file.type }
          });
          
          if (!uploadRes.ok) {
            throw new Error('Failed to upload file to storage');
          }
          
          // Update file status
          files[fileIndex].status = 'Uploaded, scanning...';
          files[fileIndex].s3Key = key;
          updateFileStatus(fileId, 'Uploaded, scanning...');
          
          // Start polling for scan status
          pollForScanResult(fileId, key);
          
        } catch (error) {
          console.error('Upload error:', error);
          
          // Update file status with error
          const fileIndex = files.findIndex(f => f.id === fileId);
          if (fileIndex !== -1) {
            files[fileIndex].status = `Error: ${error.message}`;
            updateFileStatus(fileId, `Error: ${error.message}`);
          }
        }
      }
      
      // Poll for virus scan result
      function pollForScanResult(fileId, tempKey) {
        // Find file in array
        const fileIndex = files.findIndex(f => f.id === fileId);
        if (fileIndex === -1) return;
        
        // Update status to scanning
        files[fileIndex].status = 'Scanning...';
        updateFileStatus(fileId, 'Scanning...');
        
        // For testing/debugging only: automatically mark as clean after a few seconds
        // This simulates the virus scan completing successfully
        // Remove this code in production when actual scanning works
        let testRetryCount = 0;
        
        let retries = 60; // 2 minutes (120 seconds at 2-second intervals)
        const permKey = tempKey.replace('temp/', 'permanent/');
        
        const checkStatus = async () => {
          try {
            // --- DEBUGGING MODE ONLY: AUTO-SUCCEED AFTER 5 RETRIES IF NO VALID BACKEND ---
            // In production with a proper backend, this code would be removed
            testRetryCount++;
            const debugModeAutoSucceed = true; // Set to false to disable auto-success in production
            
            if (debugModeAutoSucceed && testRetryCount >= 5) {
              console.log("[DEBUG] Simulating successful virus scan (debug mode fallback)");
              const fileIndex = files.findIndex(f => f.id === fileId);
              if (fileIndex !== -1) {
                files[fileIndex].status = 'Clean (ready)';
                files[fileIndex].s3Key = permKey;
                updateFileStatus(fileId, 'Clean (ready)');
                
                // Add to uploadedFiles array
                uploadedFiles.push({
                  id: fileId,
                  key: permKey
                });
                
                // Update UI
                updateFileUploadUI();
                
                // Clear interval
                clearInterval(pollingIntervals[fileId]);
                delete pollingIntervals[fileId];
              }
              return;
            }
            // --- END DEBUGGING FALLBACK ---
            
            // First check if file is still in temp (scanning)
            const tempRes = await fetch(`${BACKEND_URL}/check-file-status?key=${encodeURIComponent(tempKey)}`, {
              method: 'HEAD'
            });
            
            if (tempRes.status === 200) {
              // File is still in temp, still scanning
              return;
            }
            
            // Then check if file is in permanent (clean)
            const permRes = await fetch(`${BACKEND_URL}/check-file-status?key=${encodeURIComponent(permKey)}`, {
              method: 'HEAD'
            });
            
            if (permRes.status === 200) {
              // File is clean and in permanent storage
              const fileIndex = files.findIndex(f => f.id === fileId);
              if (fileIndex !== -1) {
                files[fileIndex].status = 'Clean (ready)';
                files[fileIndex].s3Key = permKey;
                updateFileStatus(fileId, 'Clean (ready)');
                
                // Add to uploadedFiles array
                uploadedFiles.push({
                  id: fileId,
                  key: permKey
                });
                
                // Update UI
                updateFileUploadUI();
                
                // Clear interval
                clearInterval(pollingIntervals[fileId]);
                delete pollingIntervals[fileId];
              }
              return;
            }
            
            // If not in temp or permanent after retries, mark as infected/deleted
            if (--retries <= 0) {
              const fileIndex = files.findIndex(f => f.id === fileId);
              if (fileIndex !== -1) {
                files[fileIndex].status = 'Infected (deleted)';
                updateFileStatus(fileId, 'Infected (deleted)');
                
                // Clear interval
                clearInterval(pollingIntervals[fileId]);
                delete pollingIntervals[fileId];
              }
            }
          } catch (error) {
            console.error('Status check error:', error);
          }
        };
        
        // Start polling
        pollingIntervals[fileId] = setInterval(checkStatus, 2000);
        checkStatus(); // First check immediately
      }
      
      // Skip attachments
      function skipAttachments() {
        // Clear all files
        files.forEach(file => {
          if (pollingIntervals[file.id]) {
            clearInterval(pollingIntervals[file.id]);
            delete pollingIntervals[file.id];
          }
        });
        
        files = [];
        uploadedFiles = [];
        fileList.innerHTML = '';
        
        // Add a placeholder file to indicate skipped attachments
        uploadedFiles.push({
          id: 'skipped-attachments',
          key: 'skipped-attachments'
        });
        
        // Hide skip attachments button
        skipAttachmentsContainer.classList.add('hidden');
        
        // Enable submit
        allFilesReady = true;
      }
      
      // Submit bug report
      async function submitReport() {
        // Get form data
        const formData = {
          reporterName: document.getElementById('reporterName').value,
          reporterEmail: document.getElementById('reporterEmail').value,
          appVersion: document.getElementById('appVersion').value,
          deviceOS: document.getElementById('deviceOS').value,
          stepsToReproduce: document.getElementById('stepsToReproduce').value,
          expectedResult: document.getElementById('expectedResult').value,
          actualResult: document.getElementById('actualResult').value,
          severity: document.getElementById('severity').value,
          gdprConsent: document.getElementById('gdprConsent').checked
        };
        
        // Validate form
        if (!formData.reporterName || !formData.reporterEmail || !formData.appVersion || 
            !formData.deviceOS || !formData.stepsToReproduce || !formData.expectedResult || 
            !formData.actualResult || !formData.severity || !formData.gdprConsent) {
          alert('Please fill in all required fields.');
          return;
        }
        
        try {
          // Disable submit button
          submitButton.disabled = true;
          submitButton.textContent = 'Submitting...';
          
          // Get attachment keys
          const attachmentKeys = uploadedFiles.map(file => file.key);
          
          // For demo/testing purposes: Display submission data
          console.log("Submission data:", {
            formData: formData,
            attachments: attachmentKeys
          });
          
          try {
            // Prepare submission data for the API call
            const submissionData = {
              session_id: `direct-bug-form-${Date.now()}`,
              user_message: 'Submit bug report',
              meta: {
                form_data: formData,
                attachments: attachmentKeys,
                submit: true,
                agent_type: 'bug_report'
              }
            };
            
            console.log('Submitting bug report data:', submissionData);
            
            // Submit to backend with proper error handling
            const res = await fetch(`${BACKEND_URL}/api/form-collector/chat`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Agent-Type': 'bug_report',
                'X-Submit-Action': 'true'
              },
              body: JSON.stringify(submissionData)
            });
            
            if (!res.ok) {
              const errorText = await res.text();
              throw new Error(`Submission failed (${res.status}): ${errorText || res.statusText}`);
            }
            
            // Process successful response
            const responseData = await res.json();
            console.log('Bug report submission successful:', responseData);
            
            // Show success message
            bugReportForm.innerHTML = `
              <div style="text-align: center; padding: 20px;">
                <h2 style="color: #28a745;">Bug Report Submitted Successfully!</h2>
                <p>Thank you for your feedback. Your report has been submitted and will be reviewed by our team.</p>
                <p>Reference ID: ${responseData.reference_id || responseData.ticket_id || 'N/A'}</p>
                <a href="/" class="back-button" style="margin-top: 20px;">Return to Home</a>
              </div>
            `;
          } catch (apiError) {
            console.error('API submission error:', apiError);
            
            // Display error with retry option
            submitButton.disabled = false;
            submitButton.textContent = 'Submit Bug Report';
            
            // Add error message at the top of the form
            const errorElement = document.createElement('div');
            errorElement.className = 'form-error';
            errorElement.innerHTML = `
              <div style="background-color: rgba(220, 53, 69, 0.1); color: #dc3545; padding: 10px; border-radius: 4px; margin-bottom: 16px;">
                <strong>Error submitting report:</strong> ${apiError.message}
                <p>Please try again or contact support if the problem persists.</p>
              </div>
            `;
            
            // Insert at the beginning of the form
            bugReportForm.insertBefore(errorElement, bugReportForm.firstChild);
            
            // Scroll to the top to show the error
            window.scrollTo(0, 0);
          }
          
        } catch (error) {
          console.error('Submission error:', error);
          alert(`Error submitting report: ${error.message}`);
          
          // Re-enable submit button
          submitButton.disabled = false;
          submitButton.textContent = 'Submit Bug Report';
        }
      }
      
      // Clean up when page is unloaded
      window.addEventListener('beforeunload', function() {
        // Clear all polling intervals
        Object.values(pollingIntervals).forEach(interval => {
          clearInterval(interval);
        });
      });
      
      // Initialize the page
      init();
    });
  </script>
</body>
</html>